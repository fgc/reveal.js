<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Implementando Prolog</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
	<section>
	  <h1>Implementando Prolog</h1>
	  <p>
	    <small>Juan Felipe García Catalán <strong>fgc@usal.es</strong></small>
	  </p>
	  <p>
	    <small>Fundamentos de Sistemas Inteligentes. 2013</small>
	  </p>
	</section>

	<section>
	  <h2>Comprobemos que Prolog no es <strong class="fragment highlight-green">magia</strong>.</h2>
	  <h3 class="fragment roll-in">implementándolo</h3>
	  <p class="fragment roll-in"><strong>... en JavaScript</strong></p>
	  <p class="fragment roll-in"><img src="assets/harryhermioneron.jpg"</p>


					   <aside class="notes">
					     Hace mes y pico aquí escuchando a Vidal... se me ocurrió esta idea
					   </aside>
	</section>

	<section>
	  <h2>¿Por qué?</h2>
	  <ul>
	    <li class="fragment">Prolog resulta muy extraño.</li>
	    <li class="fragment">Yo cuando no entiendo algo, miro dentro.</li>
	    <li class="fragment">Porque sí.</li>
	  </ul>
	  <aside class="notes">
	    1. Lenguage raro y he visto muchos, resulta difícil programar sin un modelo mental, y en este caso hay un gran salto
	    2. Todos de niño hacemos esto, sobre todo en este edificio y alrededores.
	    3. Es decir, otras razones.Orgullo friki, tiempo, aburrimiento del programador como "fontanero", no hay "magia".
	  </aside>

	</section>

	<section>
	  <h3>¿Por qué en JavaScript?</h3>
	  <img src="assets/jsgood.jpg">
	  <aside class="notes">
	    1. Lenguaje horrible. Foto. Historia. Primeras implementaciones. Corta y pega. Entorno del DOM. Usar cosas para lo que no son
	    2. Está en todas partes, es el "ensamblador" de internet. buenas herramientas, buenas implementaciones.
	    3. Las partes buenas son bastante buenas. Lispy.
	    4. Ley de Atwood. X in 30 lines of javascript.
	  </aside>

	</section>

	<section>
	  <h2>¿Cómo?</h2>
	  <span class="fragment">---&gt; Google</span><span class="fragment"> "prolog under the hood" </span>
	  <p>
	  <span class="fragment">---&gt;Stack Overflow</span>
	  <span class="fragment"><a href="http://stackoverflow.com/questions/5881432/how-does-prolog-technically-work-whats-under-the-hood"> How does Prolog technically work? What's under the hood?</a></span>
	  <p class="fragment">3 sugerencias</p>
	  <ul>
	    <li class="fragment">Mirar una implementación libre (swi-prolog).</li>
	    <li class="fragment">Libros que explican implementaciones de prolog.</li>
	    <li class="fragment" style="color: lightgreen;">Prolog se implementa sobre una máquina virtual.</li>
	  </ul>
	</section>
	<section>
	  <h1>WAM</h1>
	  <h3>Warren Abstract Machine</h3>
	  <p class="fragment">David H. D. Warren. An abstract Prolog instruction set. Technical
	    Note 309, SRI International, Menlo Park, CA, October 1983.</p>
	  <p class="fragment">Aït-Kaci, H. (1999). Warren’s Abstract Machine A TUTORIAL RECONSTRUCTION.</p>
	  <aside class="notes">
	    1970-- Intérpretes en Fortran<br>
	    1983<br>
	    tutorial? pág 19 de 120.<br>
	    al menos me da pistas sobre cómo reprentar los términos<br>
	  </aside>
	  
	</section>

	<section>
	    <p>3 sugerencias:</p>
	    <ul>
	      <li style="color: red;text-decoration:line-through" >Mirar una implementación libre (swi-prolog).</li>
	      <li style="color: lightgreen;">Libros que explican implementaciones de prolog.</li>
	      <li style="color: red;text-decoration:line-through;">Prolog se implementa sobre una máquina virtual.</li>
	    </ul>
	    <p>
	    <h2 class="fragment">¡SICP!</h2>
	  </section>

	<section>
	  <img src="assets/sicp.jpg">
	</section>
	<section>
	  <img src="assets/sussman.jpg">
	</section>
	<section>
	  <h3>Sección 4.4.4 de SICP</h3>
	  <h1>Unificación</h1>
	  <h1>+</h1>
	  <h1>Backtracking(*)</h1>
	  <aside class="notes">
	    la unificación es muy sencilla !ojo si la representación de datos es buena<br>no me molesto en explicarla con el tiempo que tenemos
	    el backtracking es lo que se puede complicar<br>
	    y ese asterisco?<br>
	  </aside>

	</section>
	<section>
	  <h3>Backtracking(*)?</h3>
	  <ul>
	      <li class="fragment">Cada unificación devuelve una sustitución válida.</li>
	      <li class="fragment">Búsqueda exhaustiva que concatena todas las sustituciones válidas en una lista <span class="fragment highlight-blue">perezosa</span> final.</li>
	      <li class="fragment">El resultado final es equivalente al de hacer backtracking "normal".</li>
	      <p>
	      <p class="fragment"><small>* Una pega, JavaScript no tiene listas perezosas...</small></p>
	      <p class="fragment roll-in" style="float:right"><small> ... Pero el propio SICP explica como implementarlas en el capítulo 3.</small></p>
	  </ul>
	  <aside class="notes">
	    Implementación muy elegante: infinitud, !!!composición!!!.<br>
	    Hay otras posibilidades más ortodoxas: amb, continuaciones.
	  </aside>
	</section>
	<section>
	  <img src="assets/streams1.png">
	</section>
	<section>
	  <img src="assets/streams2.png">
	  <aside class="notes">
	    Not también se implementa así<br>
	    Qué nos falta entonces, sólo 2 cosas importantes y muchísimas que completan el sistema.
	  </aside>
	</section>
	<section>
	  <h3>Aplicación de reglas</h3>
	    <p>Para probar la conclusión, prueba los antecedentes:</p>
	    <ol>
              <li>Unifica la consulta con la conclusión de la regla, obteniendo una nueva sustitución compatible con esta conclusión .</li>
	      <li>Con esta sustitución como entrada, evalúa la consulta formada por el cuerpo de la regla.</li>
	    </ol>
	</section>
	<section>
	  <h3>Representación de términos</h3>
	  <p>
	    <pre><code>llueve.</code></pre>
	    <pre><code data-trim>{"term":"constant", "value":"llueve"}</code></pre>
	  </p>
	  <p>
	    <pre><code>cosa(X).</code></pre>
	    <pre><code data-trim>
{
  "term":"structure", 
  "arity":"1",
  "functor":"cosa"
  "subterms":[{"term":"variable", "name":"X"}]
}</code></pre>
	  </p>
	  <aside class="notes">
	    Si hay tiempo podemos hablar de unificación
	    Menciona las listas, pero de pasada
	  </aside>
	</section>

	<section>
	  <h3>Representación de términos/2</h3>
	  <pre><code>hijo(X,Y) :- padre(Y,X), varon(X).</code></pre>
	  <pre><code data-trim>{
"term":"rule","head":{
	        "term":"structure","functor":"hijo","arity":2,
	        "subterms":[{"term":"variable","name":"X"},
                            {"term":"variable","name":"Y"}]
              },
	      "body":{"term":"conj","subterms":[
	         {"term":"structure","functor":"padre","arity":2,
                     "subterms":[{"term":"variable","name":"Y"},
                                 {"term":"variable","name":"X"}]},
                 {"term":"structure","functor":"varon","arity":1,
                      "subterms":[{"term":"variable","name":"X"}]}]}
}</code></pre>
	  <aside class="notes">
	    Esto es horroroso de teclear, la sintaxis de prolog es más simple. prefiero teclear prolog.
	  </aside>

	</section>
	<section>
	  <h2>Parsing</h2>
	  <p>PEG.js</p>
	  <pre>
	    <code>
prolog_program 
    = _ assertions:(assertion)+ {return assertions;}

assertion
    =
    assertion:(rule / term) _ "." {
        return assertion;
    }

rule
    = head:term _ ":-" _ body:termexpr {
        return {"term": "rule",
                "head": head,
                "body": body};
    }
etc... etc...

	    </code>
	  </pre>
	  <aside class="notes">
	    Equilibrio entre lo que pretendemos implementar desde cero y reinventar la rueda. Y de hecho este mismo caso es delicado
	    Y con esto tenemos una implementación básica que funciona.
	  </aside>
	</section>
	<section>
	   <h3>¿Qué tenemos?</h3>
	   <p>Criterios para añadir funcionalidad:</p>
	   <ul>
	     <li>Sintaxis y funcionalidad inspiradas en el estándar ISO</li>
	     <li>Sencillez de implementación</li>
	     <li>Que sea posible seguir tutoriales</li>
	     <li>Que sea posible implementar la práctica</li>
	   </ul>
	   <p>
	   <p class="fragment">write, true, fail, not, operaciones aritméticas, comparación</p>
		     
	</section>
	<section>
	  <h3>¿Qué nos falta?</h3>
	  <ul>
	    <li class = "fragment">!</li>
	    <li class = "fragment">asserta, assertz, assert, retract...</li>
	    <li class = "fragment">operadores dinámicos.</li>
	  </ul>
	</section>
	<section>
	  <h3>¿Qué nos llevamos?</h3>
	  <ul>
	    <li class = "fragment">técnicas de programación: listas perezosas, continuaciones.</li>
	    <li class = "fragment">puede que haya aprendido Prolog...</li>
	    <li class = "fragment">...pero al menos tengo claro que magia no hay.</li>
	  </ul>	  
	</section>
	<section>
	  <img src="assets/sadwizs.jpg">
	</section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
      controls: false,
      progress: true,
      history: true,
      center: true,

      theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
      transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

      // Parallax scrolling
      // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
      // parallaxBackgroundSize: '2100px 900px',

      // Optional libraries used to extend on reveal.js
      dependencies: [
      { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
      ]
      });

    </script>

  </body>
</html>
